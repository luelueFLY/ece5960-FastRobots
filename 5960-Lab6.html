<!DOCTYPE html>
<html lang="en">
    <head>
        <meta charset="utf-8" />
        <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no" />
        <meta name="description" content="" />
        <meta name="author" content="" />
        <title>Lab6 - Lanyue Fang's Fast Robots</title>
        <link rel="icon" type="image/x-icon" href="assets/favicon.ico" />
        <!-- Font Awesome icons (free version)-->
        <script src="https://use.fontawesome.com/releases/v5.15.4/js/all.js" crossorigin="anonymous"></script>
        <!-- Google fonts-->
        <link href="https://fonts.googleapis.com/css?family=Lora:400,700,400italic,700italic" rel="stylesheet" type="text/css" />
        <link href="https://fonts.googleapis.com/css?family=Open+Sans:300italic,400italic,600italic,700italic,800italic,400,300,600,700,800" rel="stylesheet" type="text/css" />
        <!-- Core theme CSS (includes Bootstrap)-->
        <link href="css/styles.css" rel="stylesheet" />
    </head>
    <body>
        <!-- Navigation-->
        <nav class="navbar navbar-expand-lg navbar-light" id="mainNav">
            <div class="container px-4 px-lg-5">
                <a class="navbar-brand" href="index.html">ECE5960 FAST ROBOTS</a>
                <button class="navbar-toggler" type="button" data-bs-toggle="collapse" data-bs-target="#navbarResponsive" aria-controls="navbarResponsive" aria-expanded="false" aria-label="Toggle navigation">
                    Menu
                    <i class="fas fa-bars"></i>
                </button>
                <div class="collapse navbar-collapse" id="navbarResponsive">
                    <ul class="navbar-nav ms-auto py-4 py-lg-0">
                        <li class="nav-item"><a class="nav-link px-lg-3 py-3 py-lg-4" href="index.html">Home</a></li>
                        <li class="nav-item"><a class="nav-link px-lg-3 py-3 py-lg-4" href="about.html">About Me</a></li>
                        <li class="nav-item"><a class="nav-link px-lg-3 py-3 py-lg-4" href="5960-Lab5.html">Previous</a></li>
                    </ul>
                </div>
            </div>
        </nav>
        <!-- Page Header-->
        <header class="masthead" style="background-image: url('assets/img/post-bg.jpg')">
            <div class="container position-relative px-4 px-lg-5">
                <div class="row gx-4 gx-lg-5 justify-content-center">
                    <div class="col-md-10 col-lg-8 col-xl-7">
                        <div class="post-heading">
                            <h1>Lab6 Closed-loop control (PID)</h1>
                            <h2 class="subheading">Get experience with PID control! </h2>
                            <p class="post-meta">
                                Posted by
                                Lanyue Fang
                                on Mar 14, 2022
                            </p>
                        </div>
                    </div>
                </div>
            </div>
        </header>
        <!-- Post Content-->
        <article class="mb-4">
            <div class="container px-4 px-lg-5">
                <div class="row gx-4 gx-lg-5 justify-content-center">
                    <div class="col-md-10 col-lg-8 col-xl-7">

                        <h2 class="section-heading">Maintain a Constant Orientation</h2>
                        <p>
                            In this lab, I used PID CONTROL to maintain the car in set orientation.
                            For the first part, I implemented a controller maintaining a constant orientation even when the robot is kicked. 
                            For the second part, the car was able to move forward until a new orientation, such as 180 degrees, was sent, 
                            then turning and driving towards that direction. 
                            Here are the process and details of my experiment.    
                                                        
                        </p>

                        
                        <h2 class="section-heading">Parts Required</h2>
                        <p>
                            1 x R/C stunt car<br>
                            1 x SparkFun RedBoard Artemis Nano<br>
                            1 x USB cable<br>
                            2 x Li-Ion 3.7V 400 mAh (or more) battery<br>
                            2 x Dual motor driver<br>
                            2 x 4m ToF sensor<br>
                            1 x 9DOF IMU sensor<br>
                            1 x Qwiic connector<br>
                        </p>

                        <h2 class="section-heading">Part1: Stationary Car</h2>
                        <p></p>

                        <h3>Debugging Data</h3>
                        <p>
                            To get the data feedback, I created a struct named <code>debugData</code>, 
                            storing the setpoint, current roll angle, angle error, timestamp and the motor offset.
                            <pre>
struct debugData{
    int setpoint;
    float angle_roll;
    float error;
    unsigned long timestamp;
    int motor_offset;      
};                                
                            </pre>
                            The size of the <code>debugData</code> is 16 bytes. A debugDate array is used to record all the information. 
                            Here, the array size is 1000 and will take up 16 kB memory. 
                            <pre><code>
const int MAX_DATA_SIZE=1000;
debugData datas[MAX_DATA_SIZE];
                            </code></pre>



                        </p>

                        <h3>Bluetooth Commands</h3>
                        <p>
                            As shown in below, I created several Bluetooth commands to conrtol the robot.                            
                            <pre>
enum CommandTypes
{
    BEGIN,
    STOP,
    SEND_P,
    SEND_GOAL,
    GET_ARRAY,
    PING,
};
                            </pre>
                            The robot controller will start and stop once <code>BEGIN</code> and <code>STOP</code> commands are sent to the Artemis over Bluetooth. 
                            KP value is able to change by the executing <code>ble.send_command(CMD.SEND_P, "1")</code>, so that I can update the gains without reprograming the Artemis. 
                            Similarly, <code>SEND_GOAL</code> is used to set the orientation. 
                            <p><img class="img-fluid" src="assets/img/Lab6/bluetooth01.PNG"></p>
                            
                            Once the Artemis received the command <code>GET_ARRAY</code>, function <code>write_data()</code> will be called 
                            and start to send debugging datas to the computer. 
                            Thanks for the <code>ESTRING.h</code>, the recorded datas can be converted into <code>ESTRING</code> datatype and be sent over bluetooth.
                            Here is the related code.
                            <pre><code>
write_data()
{

    for(int i=0; i < datas_index; i++){
        tx_estring_value.clear();
        tx_estring_value.append(" setpoint: ");
        tx_estring_value.append(datas[i].setpoint);tx_estring_value.append(" ");
        tx_estring_value.append(" roll: ");
        tx_estring_value.append(datas[i].angle_roll);tx_estring_value.append(" ");
        tx_estring_value.append(" error ");
        tx_estring_value.append(datas[i].error);tx_estring_value.append(" ");
        tx_estring_value.append(" timestamp: ");
        tx_estring_value.append(float(datas[i].timestamp));tx_estring_value.append(" ");
        tx_estring_value.append(" motor_offset: ");
        tx_estring_value.append(float(datas[i].motor_offset));tx_estring_value.append(" ");  
        tx_characteristic_string.writeValue(tx_estring_value.c_str()); 
    }
}
                        </code></pre>     
                        In the jupyter notebook, I created a notification handler to received the string type data consistently.
                        <p><img class="img-fluid" src="assets/img/Lab6/bluetooth02.PNG"></p>

                        </p>


                        <h3>PID control</h3>
                        <p>
                            I implemented the PID control in the main loop. 
                            Once the <code>BEGIN</code> command is sent the PID control will begin. 
                            The Artemis will get the gyroscope data, calculate the roll angle and motor offset if the IMU sensor data are ready. 
                            Otherwise, it will just skip all those things. 
                            <p></p>
                            As for the motor offset, it should be in the range of 0 to 255. 
                            Therefore, if the motor offset is less than zero, we should create PWM waves on the pins for the motor moving backward. 
                            If the motor offset is greater than 255, we should set it equal to 255.
                            <p></p>
                            Here is the related code.
                            <pre><code>

if(WAKE && datas_index < MAX_DATA_SIZE){
    if (myICM.dataReady()){
        
        // get angle(roll) from the gyro and time
        myICM.getAGMT();
        datas[datas_index].timestamp=millis();
        if(datas_index!=0){
            float dt;
            dt=(float)(datas[datas_index].timestamp-datas[datas_index-1].timestamp)*0.001;
            float wx;
            wx=myICM.gyrX();
            datas[datas_index].angle_roll=datas[datas_index-1].angle_roll+wx*dt;
        }
        else{
            datas[datas_index].angle_roll=0;
        }

        // Using PID to control the motors
        datas[datas_index].setpoint=SETPOINT;
        float error;
        error=datas[datas_index].angle_roll-SETPOINT;
        int motor_offset;
        motor_offset=P_value*error;
        if(abs(motor_offset)>255)
            motor_offset=255*(motor_offset/abs(motor_offset));
        datas[datas_index].motor_offset=motor_offset;
        
        motor_control(motor_offset);

        datas_index++;
        

    }

            
}
                            </code></pre>
                            <p></p>
                            Here, I only used P control and it was enough. I found the robot performed pretty well when the KP was 8. 
                            The demo video is attached following.
                            <p>
                                <iframe width="560" height="315" src="https://www.youtube.com/embed/eW_uqFe-xUc" title="YouTube video player" frameborder="0" allow="accelerometer; autoplay; clipboard-write; encrypted-media; gyroscope; picture-in-picture" allowfullscreen></iframe>
                            </p>

                        </p>


                        <h2 class="section-heading">Part2: Mobile Car</h2>
                        <p>
                            In this part, the car is going to move forward until a new orientation, such as 180 degree, is sent, 
                            then turning and driving towards that direction.
                        </p>
 
                        <h3>Motor Control</h3>
                        <p>
                            To control the orientation when the car is moving at a set base speed, the motor control is a little more complicated than the previous one.
                            Given that my experiment space is not so large, the base speed can not be very high. 
                            I used the speed at 25% duty cycle as the base speed, i.e., the analog value is 63. 
                            Similarly, the input analog value should be less than 255. 
                            Thus, I limited the maximum offset to be 255-SPEED_BASE.
                            Additionally, if the final input analog value is negative, speed is going to be set to the backward pins instead. 
                            Here are related codes for the offset and motor control.
                            <pre><code>
// motor offset
if(abs(motor_offset)>(255-SPEED_BASE))
    motor_offset=(255-SPEED_BASE)*(motor_offset/abs(motor_offset));
datas[datas_index].motor_offset=motor_offset;

//right motor: SPEED_BASE+motor_offset
if(SPEED_BASE+motor_offset>0)
    analogWrite(RightFoward, SPEED_BASE+motor_offset);  
else
    analogWrite(RightBack, abs(SPEED_BASE+motor_offset));

// left motor: SPEED_BASE-motor_offset
if(SPEED_BASE-motor_offset>0)
    analogWrite(LeftFoward, SPEED_BASE-motor_offset);  
else
    analogWrite(LeftBack, abs(SPEED_BASE-motor_offset));

                            </code></pre>
                        </p>
                        
                        <h3>Test Results</h3>
                        <p>
                            In the jupyter notebook, I used the following code to send commands and get debugging data. 
                            The set orientation is zero at the beginning and the car will move forward for one second. 
                            Then the setpoint will be changed to 180 degrees by the command. 
                            The car will stop after two seconds and receive the debugging data arrays. 
                            <p><img class="img-fluid" src="assets/img/Lab6/bluetooth03.PNG"></p>
                            I used the P control first. 
                            When KP is larger than 0.8, the car will drift more than 180 degrees. 
                            However, the feedback roll angles are around 180 degrees and 
                            thus the motor offset is small and the car keeps moving forward instead of adjusting orientation. 
                            I guess this is because the car turns too fast and the gyroscope misses something. 
                            <p></p>
                            I tried smaller KP but found another problem. 
                            For example, when I set the KP to be 0.75 or less, the gyroscope is able to get right angles. 
                            However, in such a situation, the motor offset is not big enough to make the car change orientation. 
                            For example, when the roll angle is 190 degrees, the motor offset will be KP * error = 0.75 * 10 = 7.5.
                            My car will go straight with such offset. 
                            I guess it is related to the coasting mode. 
                            In the last lab, I tested the deadband of the motors and found that when just one motor was spinning at a low speed, 
                            the car was able to move straight on the ground. 
                            Unfortunately, I haven't figured out a good solution to this problem. 
                            Probably adding a D control and using Kalman Filter to get the roll angle will help. 
                            Here is the demo video. 
                            <p>
                                <iframe width="560" height="315" src="https://www.youtube.com/embed/Xmy3UFYf5dg" title="YouTube video player" frameborder="0" allow="accelerometer; autoplay; clipboard-write; encrypted-media; gyroscope; picture-in-picture" allowfullscreen></iframe>
                            </p>




                        </p>

        
                       
                        

                        <p></p>

                        <span class="caption text-muted">
                            Posted by <a href="about.html">Lanyue Fang</a>
                            on Mar 14, 2022
                        </span>

                        
                       


                    </div>
                </div>
            </div>
        </article>
        <!-- Footer-->
        <footer class="border-top">
            <div class="container px-4 px-lg-5">
                <div class="row gx-4 gx-lg-5 justify-content-center">
                    <div class="col-md-10 col-lg-8 col-xl-7">
                        <div class="small text-center text-muted fst-italic">Copyright &copy; Lanyue Fang 2022</div>
                    </div>
                </div>
            </div>
        </footer>
        <!-- Bootstrap core JS-->
        <script src="https://cdn.jsdelivr.net/npm/bootstrap@5.1.3/dist/js/bootstrap.bundle.min.js"></script>
        <!-- Core theme JS-->
        <script src="js/scripts.js"></script>
    </body>
</html>
